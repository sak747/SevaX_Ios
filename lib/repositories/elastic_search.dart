import 'dart:convert';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:sevaexchange/flavor_config.dart';
import 'package:sevaexchange/l10n/l10n.dart';
import 'package:sevaexchange/models/category_model.dart';
import 'package:sevaexchange/models/community_category_model.dart';
import 'package:sevaexchange/models/offer_model.dart';
import 'package:sevaexchange/models/request_model.dart';
import 'package:sevaexchange/models/user_model.dart';
import 'package:sevaexchange/new_baseline/models/community_model.dart';
import 'package:sevaexchange/new_baseline/models/project_model.dart';
import 'package:sevaexchange/ui/utils/location_helper.dart';
import 'package:sevaexchange/utils/app_config.dart';
import 'package:sevaexchange/utils/search_via_zipcode.dart';

/// ElasticSearchApi class with web-friendly implementations
class ElasticSearchApi {
  static final String _url = FlavorConfig.values.elasticSearchBaseURL;
  static const int _requestTimeoutSeconds = 10;

  /// Make elastic search POST request with web-compatible error handling
  static Future<List<Map<String, dynamic>>> _makeElasticSearchPostRequest(
      String url, dynamic body) async {
    try {
      // Ensure the URL is properly formed for mobile compatibility
      final String fullUrl = url.startsWith('http') ? url : _url + url;
      debugPrint('Making request to: $fullUrl');
      
      final response = await http.post(
        Uri.parse(fullUrl),
        body: body,
        headers: {
          'authorization': 'basic dXNlcjpDaU4zNlVOaXhKeXE=',
          "Accept": "application/json",
          "Content-Type": "application/json"
        },
      ).timeout(Duration(seconds: _requestTimeoutSeconds));

      if (response.statusCode != 200) {
        debugPrint('API Error: ${response.statusCode} - ${response.body}');
        throw Exception('Failed to load data: ${response.statusCode} - ${response.reasonPhrase}');
      }

      final Map<String, dynamic> bodyMap = json.decode(response.body);
      final Map<String, dynamic> hitMap = bodyMap['hits'] ?? {};
      final List<dynamic> hitsDynamic = hitMap['hits'] ?? [];

      // Safely convert to the expected type
      final List<Map<String, dynamic>> hitList =
          hitsDynamic.map((item) => item as Map<String, dynamic>).toList();

      debugPrint('Successfully fetched ${hitList.length} items from $url');
      return hitList;
    } catch (e) {
      debugPrint('ElasticSearch request failed for $url: $e');
      // Log error in a web-compatible way
      _logError('ElasticSearch request failed: $e');
      rethrow; // Re-throw the error to handle it properly upstream
    }
  }

  /// Web-compatible logging function
  static void _logError(String message) {
    // Safely log errors without platform-specific dependencies
    try {
      debugPrint(message);
      // Only use console logging in web
      if (kIsWeb) {
        // Use dart:js interop safely or just log to console
        debugPrint('[Web] $message');
      }
    } catch (_) {
      // Fallback if logging fails
    }
  }

  /// Search public requests with better error handling
  static Future<List<RequestModel>> searchPublicRequests({
    required String queryString,
    UserModel? user,
    DistanceFilterData? distanceFilterData,
  }) async {
    final String endPoint = '//elasticsearch/requests/request/_search';
    try {
      debugPrint('hitting $endPoint');

      final dynamic body = json.encode(
        {
          "size": 3000,
          "query": {
            "bool": {
              "must": [
                {
                  "term": {
                    "public": true,
                  },
                },
                {
                  "term": {"accepted": false}
                },
                {
                  "term": {
                    "softDelete": false,
                  },
                },
                {
                  "term": {
                    "autoGenerated": false,
                  },
                },
                {
                  "multi_match": {
                    "query": queryString,
                    "fields": ["description", "email", "fullname", "title"],
                    "type": "phrase_prefix"
                  }
                }
              ]
            }
          }
        },
      );

      final List<Map<String, dynamic>> hitList =
          await _makeElasticSearchPostRequest(endPoint, body);

      final List<RequestModel> requestsList = [];

      for (final map in hitList) {
        final Map<String, dynamic> sourceMap = map['_source'] ?? {};
        final RequestModel model = RequestModel.fromMapElasticSearch(sourceMap);

        // Check for null location
        if (model.location == null ||
            distanceFilterData?.isInRadius(model.location!) == true) {
          final bool isTestEnvironment =
              AppConfig.isTestCommunity != null && AppConfig.isTestCommunity;

          if (isTestEnvironment) {
            if (model.liveMode == false) requestsList.add(model);
          } else {
            requestsList.add(model);
          }
        }
      }

      return requestsList;
    } catch (e) {
      debugPrint('Error searching public requests: $e');
      return Future.error("Error searching public requests: $e");
    }
  }

  /// Search public events with better error handling
  static Future<List<ProjectModel>> searchPublicEvents({
    required String queryString,
    UserModel? user,
    DistanceFilterData? distanceFilterData,
  }) async {
    final String endPoint = '//elasticsearch/sevaxprojects/_doc/_search';

    try {
      final dynamic body = json.encode(
        {
          "sort": {
            "start_time": {"order": "desc"}
          },
          "size": 3000,
          "query": {
            "bool": {
              "must": [
                {
                  "term": {
                    "public": true,
                  },
                },
                {
                  "term": {
                    "softDelete": false,
                  },
                },
                {
                  "multi_match": {
                    "query": queryString,
                    "fields": ["address", "description", "email_id", "name"],
                    "type": "phrase_prefix"
                  }
                }
              ]
            }
          }
        },
      );

      final List<Map<String, dynamic>> hitList =
          await _makeElasticSearchPostRequest(endPoint, body);

      final List<ProjectModel> projectsList = [];

      for (final map in hitList) {
        final Map<String, dynamic> sourceMap = map['_source'] ?? {};
        final ProjectModel model = ProjectModel.fromMap(sourceMap);

        // Check for null location
        if (model.location == null ||
            distanceFilterData?.isInRadius(model.location!) == true) {
          try {
            final bool isTestEnvironment =
                AppConfig.isTestCommunity != null && AppConfig.isTestCommunity;

            if (isTestEnvironment) {
              if (model.liveMode == false) projectsList.add(model);
            } else {
              projectsList.add(model);
            }
          } catch (e) {
            debugPrint('Error processing project: $e');
          }
        }
      }

      projectsList.sort((a, b) => (a.name ?? '').compareTo(b.name ?? ''));
      return projectsList;
    } catch (e) {
      debugPrint('Error searching public events: $e');
      return Future.error("Error searching public events: $e");
    }
  }

  /// Search public offers with better error handling
  static Future<List<OfferModel>> searchPublicOffers({
    required String queryString,
    UserModel? user,
    DistanceFilterData? distanceFilterData,
  }) async {
    final String endPoint = '//elasticsearch/offers/_doc/_search';

    try {
      final dynamic body = json.encode({
        "size": 3000,
        "query": {
          "bool": {
            "must": [
              {
                "term": {
                  "softDelete": false,
                },
              },
              {
                "term": {
                  "autoGenerated": false,
                },
              },
              {
                "term": {
                  "public": true,
                },
              },
              {
                "bool": {
                  "should": [
                    {
                      "nested": {
                        "path": "individualOfferDataModel",
                        "query": {
                          "bool": {
                            "should": {
                              "multi_match": {
                                "query": queryString,
                                "fields": [
                                  "individualOfferDataModel.description",
                                  "individualOfferDataModel.title"
                                ],
                                "type": "phrase_prefix"
                              }
                            }
                          }
                        }
                      }
                    },
                    {
                      "nested": {
                        "path": "groupOfferDataModel",
                        "query": {
                          "bool": {
                            "should": {
                              "multi_match": {
                                "query": queryString,
                                "fields": [
                                  "groupOfferDataModel.classDescription",
                                  "groupOfferDataModel.classTitle"
                                ],
                                "type": "phrase_prefix"
                              }
                            }
                          }
                        }
                      }
                    },
                    {
                      "multi_match": {
                        "query": queryString,
                        "fields": ["email", "fullname", "selectedAdrress"],
                        "type": "phrase_prefix"
                      }
                    }
                  ]
                }
              }
            ]
          }
        }
      });

      final List<Map<String, dynamic>> hitList =
          await _makeElasticSearchPostRequest(endPoint, body);

      final List<OfferModel> offersList = [];

      for (final map in hitList) {
        final Map<String, dynamic> sourceMap = map['_source'] ?? {};
        final OfferModel model = OfferModel.fromMapElasticSearch(sourceMap);

        // Check for null location
        if (model.location == null ||
            distanceFilterData?.isInRadius(model.location!) == true) {
          try {
            final bool isTestEnvironment =
                AppConfig.isTestCommunity != null && AppConfig.isTestCommunity;

            if (isTestEnvironment) {
              if (model.liveMode == false) offersList.add(model);
            } else {
              offersList.add(model);
            }
          } catch (e) {
            debugPrint('Error processing offer: $e');
          }
        }
      }

      return offersList;
    } catch (e) {
      debugPrint('Error searching public offers: $e');
      return Future.error("Error searching public offers: $e");
    }
  }

  /// Search communities with better error handling
  static Future<List<CommunityModel>> searchCommunity({
    required String queryString,
    required bool isSignedIn,
    DistanceFilterData? distanceFilterData,
  }) async {
    final Map<String, CommunityModel> communityList = {};

    try {
      if (isSignedIn) {
        try {
          final List<CommunityModel> communityListTemp =
              await SearchCommunityViaZIPCode.getCommunitiesViaZIPCode(
                  queryString);

          debugPrint(
              "Found ${communityListTemp.length} communities via ZIP code");

          for (final item in communityListTemp) {
            communityList[item.id] = item;
          }
        } catch (e) {
          debugPrint("No nearby communities found via ZIP: $e");
        }
      }

      final String endPoint = '//elasticsearch/sevaxcommunities/_doc/_search';
      final dynamic body = json.encode({
        "query": {
          "bool": {
            "must": [
              {
                "term": {
                  "softDelete": false,
                }
              },
              {
                "term": {
                  "private": false,
                }
              },
              {
                "multi_match": {
                  "query": queryString,
                  "fields": [
                    "name",
                    "billing_address.country",
                    "billing_address.city",
                    "billing_address.state",
                    "billing_address.pincode",
                  ],
                  "type": "phrase_prefix"
                }
              }
            ]
          }
        },
        "sort": {
          "created_at.keyword": {"order": "desc"}
        },
      });

      final List<Map<String, dynamic>> hitList =
          await _makeElasticSearchPostRequest(endPoint, body);

      for (final map in hitList) {
        try {
          final Map<String, dynamic> sourceMap = map['_source'] ?? {};
          final CommunityModel model = CommunityModel(sourceMap);

          final bool isInRadius =
              distanceFilterData?.isInRadius(model.location) ?? true;
          final bool isTestEnvironment =
              AppConfig.isTestCommunity != null && AppConfig.isTestCommunity;

          if (isInRadius) {
            if (isTestEnvironment) {
              if (model.testCommunity) communityList[model.id] = model;
            } else {
              communityList[model.id] = model;
            }
          }
        } catch (e) {
          debugPrint('Error processing community: $e');
        }
      }

      final List<CommunityModel> communities = communityList.values.toList();
      communities.sort((a, b) => a.name.compareTo(b.name));

      return communities;
    } catch (e) {
      debugPrint('Error searching communities: $e');
      return Future.error("Error searching communities: $e");
    }
  }

  /// Get public offers with better error handling
  static Future<List<OfferModel>> getPublicOffers({
    DistanceFilterData? distanceFilterData,
    int maxRetries = 3,
  }) async {
    final String endPoint = '//elasticsearch/offers/_doc/_search?size=1000';

    int retryCount = 0;
    Exception? lastError;

    while (retryCount < maxRetries) {
      try {
        final bool isTestEnvironment =
            AppConfig.isTestCommunity != null && AppConfig.isTestCommunity;

        final dynamic body = json.encode({
          "query": {
            "bool": {
              "must": [
                {
                  "term": {"liveMode": isTestEnvironment ? false : true}
                },
                {
                  "term": {"public": true}
                },
                {
                  "term": {"softDelete": false}
                },
                {
                  "term": {"autoGenerated": false}
                }
              ]
            }
          }
        });

        final List<Map<String, dynamic>> hitList =
            await _makeElasticSearchPostRequest(endPoint, body);

        final List<OfferModel> models = [];

        for (final map in hitList) {
          try {
            final Map<String, dynamic> sourceMap = map['_source'] ?? {};
            final OfferModel model = OfferModel.fromMap(sourceMap);

            if (model.location == null ||
                distanceFilterData?.isInRadius(model.location!) == true) {
              if (isTestEnvironment) {
                if (model.liveMode == false) models.add(model);
              } else {
                models.add(model);
              }
            }
          } catch (e) {
            debugPrint('Error processing individual offer: $e');
            // Continue processing other offers even if one fails
          }
        }

        models.sort((a, b) => (a.fullName ?? '').compareTo(b.fullName ?? ''));
        debugPrint('Successfully loaded ${models.length} public offers');
        return models;
      } catch (e) {
        lastError = e as Exception;
        retryCount++;
        debugPrint('Attempt $retryCount failed for getPublicOffers: $e');
        
        if (retryCount < maxRetries) {
          // Wait before retrying with exponential backoff
          await Future.delayed(Duration(milliseconds: 500 * retryCount));
        }
      }
    }
    
    debugPrint('All $maxRetries attempts failed for getPublicOffers. Last error: $lastError');
    throw Exception("Failed to load offers after $maxRetries attempts. Last error: $lastError");
  }

  /// Get public communities with better error handling
  static Future<List<CommunityModel>> getPublicCommunities({
    DistanceFilterData? distanceFilterData,
  }) async {
    final String endPoint =
        '//elasticsearch/sevaxcommunities/_doc/_search?size=1000';

    try {
      final bool isTestEnvironment =
          AppConfig.isTestCommunity != null && AppConfig.isTestCommunity;

      final dynamic body = json.encode({
        "query": {
          "bool": {
            "must": [
              {
                "term": {"private": false}
              },
              {
                "term": {"softDelete": false}
              },
              {
                "term": {"testCommunity": isTestEnvironment ? true : false}
              },
            ]
          }
        }
      });

      final List<Map<String, dynamic>> hitList =
          await _makeElasticSearchPostRequest(endPoint, body);

      final List<CommunityModel> models = [];

      for (final map in hitList) {
        final Map<String, dynamic> sourceMap = map['_source'] ?? {};
        final CommunityModel model = CommunityModel(sourceMap);

        if (distanceFilterData?.isInRadius(model.location) ?? true) {
          if (isTestEnvironment) {
            if (model.testCommunity) models.add(model);
          } else {
            models.add(model);
          }
        }
      }

      return models;
    } catch (e) {
      debugPrint('Error getting public communities: $e');
      return Future.error("Error getting public communities: $e");
    }
  }

  /// Get public requests with better error handling
  static Future<List<RequestModel>> getPublicRequests({
    DistanceFilterData? distanceFilterData,
    int maxRetries = 3,
  }) async {
    final String endPoint =
        '//elasticsearch/requests/request/_search?size=1000';

    int retryCount = 0;
    Exception? lastError;

    while (retryCount < maxRetries) {
      try {
        final bool isTestEnvironment =
            AppConfig.isTestCommunity != null && AppConfig.isTestCommunity;

        final dynamic body = json.encode(
          {
            "query": {
              "bool": {
                "must": [
                  {
                    "term": {"liveMode": isTestEnvironment ? false : true}
                  },
                  {
                    "term": {"public": true}
                  },
                  {
                    "term": {"softDelete": false}
                  },
                  {
                    "term": {"autoGenerated": false}
                  },
                  {
                    "term": {"accepted": false}
                  },
                ]
              }
            },
            "sort": {
              "posttimestamp": {"order": "desc"}
            }
          },
        );

        final List<Map<String, dynamic>> hitList =
            await _makeElasticSearchPostRequest(endPoint, body);

        final List<RequestModel> models = [];

        for (final map in hitList) {
          try {
            final Map<String, dynamic> sourceMap = map['_source'] ?? {};
            final RequestModel model = RequestModel.fromMap(sourceMap);

            if (model.location == null ||
                distanceFilterData?.isInRadius(model.location!) == true) {
              if (!(model.accepted ?? false)) {
                if (isTestEnvironment) {
                  if (model.liveMode == false) models.add(model);
                } else {
                  models.add(model);
                }
              }
            }
          } catch (e) {
            debugPrint('Error processing individual request: $e');
            // Continue processing other requests even if one fails
          }
        }

        debugPrint('Successfully loaded ${models.length} public requests');
        return models;
      } catch (e) {
        lastError = e as Exception;
        retryCount++;
        debugPrint('Attempt $retryCount failed for getPublicRequests: $e');
        
        if (retryCount < maxRetries) {
          // Wait before retrying with exponential backoff
          await Future.delayed(Duration(milliseconds: 500 * retryCount));
        }
      }
    }
    
    debugPrint('All $maxRetries attempts failed for getPublicRequests. Last error: $lastError');
    throw Exception("Failed to load requests after $maxRetries attempts. Last error: $lastError");
  }

  /// Get all categories with better error handling
  static Future<List<CategoryModel>> getAllCategories(
      BuildContext context) async {
    try {
      final String key = S.of(context).localeName ?? 'en';
      final String endPoint =
          '//elasticsearch/request_categories/_doc/_search?size=200';

      final dynamic body = json.encode({
        "query": {"match_all": {}},
        "sort": {
          "title_en.keyword": {"order": "asc"}
        }
      });

      final List<Map<String, dynamic>> hitList =
          await _makeElasticSearchPostRequest(endPoint, body);

      final List<CategoryModel> categoryList = [];

      for (final map in hitList) {
        try {
          final Map<String, dynamic> sourceMap = map['_source'] ?? {};
          final String fieldKey = "title_${key}";

          if (sourceMap[fieldKey] != null) {
            final CategoryModel model = CategoryModel.fromMap(sourceMap);
            categoryList.add(model);
          }
        } catch (e) {
          debugPrint('Error creating category model: $e');
        }
      }

      return categoryList;
    } catch (e) {
      debugPrint('Error getting all categories: $e');
      return Future.error("Error getting all categories: $e");
    }
  }

  /// Cache for community categories to avoid repeated network requests
  static List<CommunityCategoryModel>? _communityCategoriesCache;
  static DateTime? _communityCategoriesCacheTime;
  static const Duration _cacheValidityDuration = Duration(minutes: 5);

  /// Get all community categories with improved caching and faster loading
  static Future<List<CommunityCategoryModel>>
      getAllCommunityCategories() async {
    // Check if we have valid cached data
    if (_communityCategoriesCache != null &&
        _communityCategoriesCacheTime != null &&
        DateTime.now().difference(_communityCategoriesCacheTime!) <
            _cacheValidityDuration) {
      debugPrint('Returning cached community categories');
      return Future.value(_communityCategoriesCache);
    }

    try {
      final String endPoint =
          '//elasticsearch/community_categories/_doc/_search?size=100';

      final dynamic body = json.encode({
        "query": {"match_all": {}},
        "sort": {
          "en.keyword": {"order": "asc"}
        },
        "_source": ["id", "en", "data", "logo"]
      });

      // Set a shorter timeout for category requests
      final response = await http.post(
        Uri.parse(endPoint.startsWith('http') ? endPoint : _url + endPoint),
        body: body,
        headers: {
          'authorization': 'basic dXNlcjpDaU4zNlVOaXhKeXE=',
          "Accept": "application/json",
          "Content-Type": "application/json"
        },
      ).timeout(Duration(seconds: 5));

      if (response.statusCode != 200) {
        throw Exception('Failed to load community categories: ${response.statusCode}');
      }

      final Map<String, dynamic> bodyMap = json.decode(response.body);
      final Map<String, dynamic> hitMap = bodyMap['hits'] ?? {};
      final List<dynamic> hitsDynamic = hitMap['hits'] ?? [];

      final List<CommunityCategoryModel> categoryList = [];

      for (final map in hitsDynamic) {
        try {
          final Map<String, dynamic> sourceMap = map['_source'] ?? {};
          final CommunityCategoryModel model =
              CommunityCategoryModel.fromMap(sourceMap);
          categoryList.add(model);
        } catch (e) {
          debugPrint('Error parsing community category: $e');
        }
      }

      // Cache the results
      _communityCategoriesCache = categoryList;
      _communityCategoriesCacheTime = DateTime.now();

      debugPrint('Loaded ${categoryList.length} community categories');
      return categoryList;
    } catch (e) {
      debugPrint('Error getting all community categories: $e');
      
      // Return cached data even if expired if available
      if (_communityCategoriesCache != null) {
        debugPrint('Returning expired cache for community categories');
        return _communityCategoriesCache!;
      }
      
      // Return empty list as fallback instead of throwing error
      return [];
    }
  }

  /// Get requests by category with better error handling
  static Future<List<RequestModel>> getRequestsByCategory(String typeId) async {
    try {
      final String endPoint = '//elasticsearch/requests/request/_search';
      final bool isTestEnvironment =
          AppConfig.isTestCommunity != null && AppConfig.isTestCommunity;

      final dynamic body = json.encode(
        {
          "query": {
            "bool": {
              "must": [
                {
                  "term": {"liveMode": isTestEnvironment ? false : true}
                },
                {
                  "term": {"public": true}
                },
                {
                  "term": {"accepted": false}
                },
                {
                  "term": {"softDelete": false}
                },
                {
                  "match": {"categories": typeId}
                },
              ]
            }
          },
          "sort": {
            "posttimestamp": {"order": "desc"}
          }
        },
      );

      final List<Map<String, dynamic>> hitList =
          await _makeElasticSearchPostRequest(endPoint, body);

      final List<RequestModel> models = [];

      for (final map in hitList) {
        final Map<String, dynamic> sourceMap = map['_source'] ?? {};
        final RequestModel model = RequestModel.fromMap(sourceMap);

        if (!(model.accepted ?? false)) {
          models.add(model);
        }
      }

      return models;
    } catch (e) {
      debugPrint('Error getting requests by category: $e');
      return Future.error("Error getting requests by category: $e");
    }
  }

  /// Get public projects with better error handling
  static Future<List<ProjectModel>> getPublicProjects({
    DistanceFilterData? distanceFilterData,
    String? sevaUserID,
    bool? showCompletedEvent,
    int maxRetries = 3,
  }) async {
    int retryCount = 0;
    Exception? lastError;

    while (retryCount < maxRetries) {
      try {
        final String endPoint =
            '//elasticsearch/sevaxprojects/_doc/_search?size=1000';
        final bool isTestEnvironment =
            AppConfig.isTestCommunity != null && AppConfig.isTestCommunity;

        final dynamic body = json.encode({
          "sort": {
            "start_time": {"order": "desc"}
          },
          "query": {
            "bool": {
              "must": [
                {
                  "term": {"liveMode": isTestEnvironment ? false : true}
                },
                {
                  "term": {"public": true}
                },
                {
                  "term": {"softDelete": false}
                },
                {
                  "term": {"autoGenerated": false}
                }
              ]
            }
          }
        });

        final List<Map<String, dynamic>> hitList =
            await _makeElasticSearchPostRequest(endPoint, body);

        final List<ProjectModel> models = [];

        for (final map in hitList) {
          try {
            final Map<String, dynamic> sourceMap = map['_source'] ?? {};
            final ProjectModel model = ProjectModel.fromMap(sourceMap);

            // Safely get end time with null handling
            final int endTimeMillis = model.endTime ?? 0;
            final DateTime endDate =
                DateTime.fromMillisecondsSinceEpoch(endTimeMillis);

            if (model.location == null ||
                distanceFilterData?.isInRadius(model.location!) == true) {
              // Handle completed events
              if (showCompletedEvent == true) {
                if (endDate.isAfter(DateTime.now().subtract(Duration(days: 365))) &&
                    endDate.isBefore(DateTime.now())) {
                  _addProjectIfApplicable(model, isTestEnvironment, models);
                }
              } else {
                if (endDate.isBefore(DateTime.now())) {
                  // For past events, only add if user is involved
                  if ((sevaUserID != null && sevaUserID.isNotEmpty) &&
                      (model.creatorId == sevaUserID ||
                          (model.members != null &&
                              model.members!.contains(sevaUserID)) ||
                          model.associatedmembers?.containsKey(sevaUserID) ==
                              true)) {
                    _addProjectIfApplicable(model, isTestEnvironment, models);
                  }
                } else {
                  // For future events, add all
                  _addProjectIfApplicable(model, isTestEnvironment, models);
                }
              }
            }
          } catch (e) {
            debugPrint('Error processing individual project: $e');
            // Continue processing other projects even if one fails
          }
        }

        debugPrint('Successfully loaded ${models.length} public projects');
        return models;
      } catch (e) {
        lastError = e as Exception;
        retryCount++;
        debugPrint('Attempt $retryCount failed for getPublicProjects: $e');
        
        if (retryCount < maxRetries) {
          // Wait before retrying with exponential backoff
          await Future.delayed(Duration(milliseconds: 500 * retryCount));
        }
      }
    }
    
    debugPrint('All $maxRetries attempts failed for getPublicProjects. Last error: $lastError');
    throw Exception("Failed to load projects after $maxRetries attempts. Last error: $lastError");
  }

  /// Helper method to add project to list
  static void _addProjectIfApplicable(
      ProjectModel model, bool isTestEnvironment, List<ProjectModel> models) {
    if (isTestEnvironment) {
      if (model.liveMode == false) models.add(model);
    } else {
      models.add(model);
    }
  }

  /// Get communities by category with better error handling
  static Future<List<CommunityModel>> getCommunitiesByCategory(
      String communityCategoryId) async {
    try {
      final String endPoint =
          '//elasticsearch/sevaxcommunities/_doc/_search?size=1000';

      final dynamic body = json.encode({
        "sort": {
          "created_at.keyword": {"order": "desc"}
        },
        "query": {
          "bool": {
            "must": [
              {
                "query_string": {
                  "default_field": "communityCategories",
                  "query": communityCategoryId
                }
              },
              {
                "term": {"private": false}
              },
              {
                "term": {"softDelete": false}
              }
            ]
          }
        }
      });

      final List<Map<String, dynamic>> hitList =
          await _makeElasticSearchPostRequest(endPoint, body);

      final List<CommunityModel> models = [];

      for (final map in hitList) {
        final Map<String, dynamic> sourceMap = map['_source'] ?? {};
        final CommunityModel model = CommunityModel(sourceMap);
        models.add(model);
      }

      return models;
    } catch (e) {
      debugPrint('Error getting communities by category: $e');
      return Future.error("Error getting communities by category: $e");
    }
  }

  /// Get featured communities with better error handling
  static Future<List<CommunityModel>> getFeaturedCommunities() async {
    try {
      final String endPoint =
          '//elasticsearch/sevaxcommunities/_doc/_search?size=10';
      final bool isTestEnvironment =
          AppConfig.isTestCommunity != null && AppConfig.isTestCommunity;

      final dynamic body = json.encode({
        "query": {
          "bool": {
            "must": [
              {
                "term": {"testCommunity": isTestEnvironment ? true : false}
              },
              {
                "term": {"private": false}
              },
              {
                "term": {"softDelete": false}
              }
            ]
          }
        },
        "sort": {
          "featuredCommunity": {"order": "desc"}
        }
      });

      final List<Map<String, dynamic>> hitList =
          await _makeElasticSearchPostRequest(endPoint, body);

      final List<CommunityModel> models = [];

      for (final map in hitList) {
        try {
          final Map<String, dynamic> sourceMap = map['_source'] ?? {};
          final CommunityModel model = CommunityModel(sourceMap);
          models.add(model);
        } catch (e) {
          debugPrint('Error creating community model: $e');
        }
      }

      return models;
    } catch (e) {
      debugPrint('Error getting featured communities: $e');
      return Future.error("Error getting featured communities: $e");
    }
  }
}
