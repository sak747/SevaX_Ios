import 'package:flutter/material.dart';
import 'package:rxdart/rxdart.dart';
import 'package:rxdart/subjects.dart';
import 'package:sevaexchange/components/ProfanityDetector.dart';
import 'package:sevaexchange/components/calendar_events/models/kloudless_models.dart';
import 'package:sevaexchange/components/calendar_events/module/index.dart';
import 'package:sevaexchange/constants/sevatitles.dart';
import 'package:sevaexchange/models/models.dart';
import 'package:sevaexchange/models/user_model.dart';
import 'package:sevaexchange/ui/utils/offer_utility.dart';
import 'package:sevaexchange/ui/utils/validators.dart';
import 'package:sevaexchange/utils/app_config.dart';
import 'package:sevaexchange/utils/bloc_provider.dart';
import 'package:sevaexchange/utils/data_managers/offers_data_manager.dart';
import 'package:sevaexchange/utils/log_printer/log_printer.dart';

import '../../../../flavor_config.dart';

class OneToManyOfferBloc extends BlocBase {
  int? startTime;
  int? endTime;
  bool offerCreatedBool = false;
  bool autoGenerated = false;
  bool allowedCalenderEvent = false;
  bool isRecurring = false;
  List<int> recurringDays = [];
  int? occurenceCount;
  End? end;
  String? parent_offer_id;
  OfferModel? mainOfferModel;
  List<String> offerIds = [];
  final _makePublic = BehaviorSubject<bool>();
  final _makeVirtual = BehaviorSubject<bool>();

  final _title = BehaviorSubject<String>();
  final _preparationHours = BehaviorSubject<String>();
  final _classHours = BehaviorSubject<String>();
  final _classSize = BehaviorSubject<String>();
  final _classDescription = BehaviorSubject<String>();
  final _location = BehaviorSubject<CustomLocation>();
  final _status = BehaviorSubject<Status>.seeded(Status.IDLE);
  final _classSizeError = BehaviorSubject<String>();
  final profanityDetector = ProfanityDetector();
  final _isVisible = BehaviorSubject<bool>.seeded(false);

  Function(bool value) get onOfferMadePublic => _makePublic.sink.add;

  void onOfferMadeVirtual(bool value) {
    if (value != null) {
      if (!value) {
        onOfferMadePublic(false);
      }
      _isVisible.add(value);
      _makeVirtual.add(value);
    }
  }

  Function(String value) get onTitleChanged => _title.sink.add;

  Function(String) get onPreparationHoursChanged => _preparationHours.sink.add;

  Function(String) get onClassHoursChanged => _classHours.sink.add;

  Function(String) get onClassSizeChanged => _classSize.sink.add;

  Function(String) get onclassDescriptionChanged => _classDescription.sink.add;

  Function(CustomLocation) get onLocatioChanged => _location.sink.add;

  Function(String) get onClassSizeError => _classSizeError.sink.add;

  // Function(bool) get isAdminChanged => _isAdmin.sink.add;
  Stream<bool> get isVisible => _isVisible.stream;

  Stream<bool> get makePublicValue => _makePublic.stream;

  Stream<bool> get makeVirtualValue => _makeVirtual.stream;

  Stream<String> get title => _title.stream;

  Stream<String> get preparationHours => _preparationHours.stream;

  Stream<String> get classHours => _classHours.stream;

  Stream<String> get classSize => _classSize.stream;

  // Stream<bool> get isAdmin => _isAdmin.stream;
  Stream<String> get classDescription => _classDescription.stream;

  Stream<CustomLocation> get location => _location.stream;

  Stream<String> get classSizeError => _classSizeError.stream;

  Stream<Status> get status => _status.stream;

  ///[Function] to create or update offer
  void createOneToManyOffer({
    UserModel? user,
    String? timebankId,
    String? communityName,
    required BuildContext context,
  }) async {
    if (!validateForm()) {
      int prepHours = int.parse(_preparationHours.value);
      int classHours = int.parse(_classHours.value);
      int classSize = int.parse(_classSize.value);

      if (prepHours + classHours > classSize * classHours) {
        _status.add(Status.LOADING);
        var timestamp = DateTime.now().millisecondsSinceEpoch;
        var id = '${user!.email}*$timestamp';
        var parent_offer_id = id;

        OfferModel offerModel = OfferModel(
            id: id,
            email: user.email,
            softDelete: false,
            fullName: user.fullname,
            sevaUserId: user.sevaUserID,
            timebankId: timebankId,
            type: RequestType.ONE_TO_MANY_OFFER,
            communityId: user.currentCommunity,
            photoUrlImage: user.photoURL ?? defaultUserImageURL,
            creatorAllowedCalender: allowedCalenderEvent,
            allowedCalenderUsers: allowedCalenderEvent ? [user.email!] : [],
            selectedAdrress:
                _location.value == null ? null : _location.value.address,
            timestamp: timestamp,
            location: _location.value == null ? null : _location.value.location,
            liveMode: !AppConfig.isTestCommunity,
            public: _makePublic.value ?? false,
            virtual: _makeVirtual.value ?? false,
            timebanksPosted: _makePublic.value ?? false
                ? [timebankId!, FlavorConfig.values.timebankId]
                : [timebankId!],
            groupOfferDataModel: GroupOfferDataModel()
              ..classTitle = _title.value
              ..startDate = startTime!
              ..endDate = endTime!
              ..numberOfPreperationHours = prepHours
              ..numberOfClassHours = classHours
              ..sizeOfClass = classSize
              ..classDescription = _classDescription.value,
            individualOfferDataModel: IndividualOfferDataModel(),
            offerType: OfferType.GROUP_OFFER,
            communityName: communityName);
        offerModel.autoGenerated = autoGenerated;
        offerModel.isRecurring = isRecurring;
        if (offerModel.isRecurring!) {
          offerModel.recurringDays = recurringDays;
          offerModel.end = end;
          offerModel.occurenceCount = occurenceCount;
          offerModel.parent_offer_id = parent_offer_id;
        }

        await createOffer(offerModel: offerModel).then((_) {
          if (offerModel.id != null) {
            offerIds.add(offerModel.id!);
          }
          if (offerModel.isRecurring ?? false) {
            return createRecurringEventsOffer(offerModel: offerModel);
          }
          return <String>[];
        }).then((offerIdsList) {
          if (offerModel.isRecurring!) {
            (offerIdsList as List<String>).forEach((Id) {
              offerIds.add(Id);
            });
          }
          offerCreatedBool = true;
          mainOfferModel = offerModel;
          _status.add(Status.COMPLETE);

          new KloudlessWidgetManager<CreateMode, OfferModel>().syncCalendar(
            context: context,
            builder:
                KloudlessWidgetBuilder().fromContext<CreateMode, OfferModel>(
              context: context,
              id: offerModel.id!,
              model: offerModel,
            ),
          );
        }).catchError((e) => _status.add(Status.ERROR));
      } else {
        _classSizeError.add(ValidationErrors.offerCreditError);
      }
    }
  }

  void updateOneToManyOffer(OfferModel offerModel, int editType) {
    OfferModel offer = offerModel;
    if (!validateForm()) {
      int prepHours = int.parse(_preparationHours.value);
      int classHours = int.parse(_classHours.value);
      int classSize = int.parse(_classSize.value);
      if (prepHours + classHours < classSize * classHours) {
        _status.add(Status.LOADING);
        offer.location = _location.value.location;
        offer.selectedAdrress = _location.value.address;
        offer.public = _makePublic.value ?? false;
        offer.virtual = _makeVirtual.value;
        offer.timebanksPosted = _makeVirtual.value
            ? [offer.timebankId!, FlavorConfig.values.timebankId]
            : [offer.timebankId!];
        offer.groupOfferDataModel = GroupOfferDataModel()
          ..classTitle = _title.value
          ..startDate = startTime!
          ..endDate = endTime!
          ..numberOfPreperationHours = prepHours
          ..numberOfClassHours = classHours
          ..sizeOfClass = classSize
          ..classDescription = _classDescription.value;

        offer.autoGenerated = autoGenerated;
        offer.isRecurring = isRecurring;

        if (offer.isRecurring! || offer.autoGenerated!) {
          offer.recurringDays = recurringDays;
          offer.end = end;
          offer.occurenceCount = occurenceCount;
        }

        updateOfferWithRequest(offer: offer).then((_) {
          if (editType == 1) {
            return updateRecurrenceOffersFrontEnd(updatedOfferModel: offer);
          }
          return 1;
        }).then((_) {
          _status.add(Status.COMPLETE);
        }).catchError((e) => _status.add(Status.ERROR));
      } else {
        _classSizeError.add(ValidationErrors.offerCreditError);
      }
    }
  }

  // void checkPublicAvailability(String timebankId, String sevaUserId) {
  //   CollectionRef
  //       .timebank
  //       .doc(timebankId)
  //       .get()
  //       .then((value) {
  //     final model = TimebankModel.fromMap(value.data());
  //     isAdminChanged(model.admins.contains(sevaUserId) ||
  //         model.organizers.contains(sevaUserId));
  //   });
  // }

  ///[PRELOAD DATA FOR UPDATE]
  void loadData(OfferModel offerModel) {
    _title.add(
      offerModel.groupOfferDataModel!.classTitle!,
    );
    _preparationHours.add(
      offerModel.groupOfferDataModel!.numberOfPreperationHours.toString(),
    );
    _classHours.add(
      offerModel.groupOfferDataModel!.numberOfClassHours.toString(),
    );
    _classSize.add(offerModel.groupOfferDataModel!.sizeOfClass.toString());
    _classDescription.add(
      offerModel.groupOfferDataModel!.classDescription!,
    );
    _isVisible.add(offerModel.public!);
    _makePublic.add(offerModel.public!);
    _makeVirtual.add(offerModel.virtual!);
    _location.add(
      CustomLocation(
        offerModel.location!,
        offerModel.selectedAdrress!,
      ),
    );
  }

  String? validateOfferTitle(String value) {
    if (value == null || value == '') {
      _title.addError(ValidationErrors.titleError);
      return ValidationErrors.titleError;
    } else if (value.substring(0, 1).contains('_') &&
        !AppConfig.testingEmails.contains(AppConfig.loggedInEmail)) {
      _title.addError(ValidationErrors.char_error);
      return ValidationErrors.char_error;
    } else if (profanityDetector.isProfaneString(value)) {
      _title.addError(ValidationErrors.profanityError);
      return ValidationErrors.profanityError;
    }
    return null;
  }

  String? validateOfferDescription(String value) {
    if (value == null || value == '') {
      _classDescription.addError(ValidationErrors.genericError);
      return ValidationErrors.genericError;
    } else if (profanityDetector.isProfaneString(value)) {
      _classDescription.addError(ValidationErrors.profanityError);
      return ValidationErrors.profanityError;
    }
    return null;
  }

  RegExp numberCheck = RegExp(r"^0*[1-9]\d*$");

  String? validateOfferClassHours(String value) {
    if (_classHours.value == null || !numberCheck.hasMatch(_classHours.value)) {
      _classHours.addError(ValidationErrors.classHours);
      return ValidationErrors.classHours;
    }
    return null;
  }

  String? validateOfferClassSize(String value) {
    if (_classSize.value == null || !numberCheck.hasMatch(_classSize.value)) {
      _classSize.addError(ValidationErrors.sizeOfClassError);
      return ValidationErrors.sizeOfClassError;
    }
    return null;
  }

  RegExp numberWithZeroCheck = RegExp(r"^\d+$");

  String? validatePrepHours(String value) {
    if (_preparationHours.value == null ||
        !numberWithZeroCheck.hasMatch(_preparationHours.value)) {
      _preparationHours.addError(ValidationErrors.preprationTimeError);
      return ValidationErrors.preprationTimeError;
    }
    return null;
  }

  bool validateForm() {
    return !(validateOfferTitle(_title.value) == null &&
        validateOfferDescription(_classDescription.value) == null &&
        validatePrepHours(_preparationHours.value.toString()) == null &&
        validateOfferClassHours(_classHours.value.toString()) == null &&
        validateOfferClassSize(_classSize.value.toString()) == null);
  }

  ///[ERROR CHECKS] TO Validate input
  bool errorCheck() {
    RegExp numberCheck = RegExp(r"^0*[1-9]\d*$");
    RegExp numberWithZeroCheck = RegExp(r"^\d+$");

    bool flag = false;
    if (_title.value == null || _title.value == '') {
      _title.addError(ValidationErrors.titleError);
      flag = true;
    } else if (_title.value.substring(0, 1).contains('_') &&
        !AppConfig.testingEmails.contains(AppConfig.loggedInEmail)) {
      _title.addError(ValidationErrors.char_error);
      flag = true;
    } else {
      if (profanityDetector.isProfaneString(_title.value)) {
        _title.addError(ValidationErrors.profanityError);
        flag = true;
      }
    }
    if (_classDescription.value == null || _classDescription.value == '') {
      _classDescription.addError(ValidationErrors.genericError);
      flag = true;
    } else {
      if (profanityDetector.isProfaneString(_classDescription.value)) {
        _classDescription.addError(ValidationErrors.profanityError);
        flag = true;
      }
    }
    if (_classHours.value == null || !numberCheck.hasMatch(_classHours.value)) {
      _classHours.addError(ValidationErrors.classHours);
      flag = true;
    }

    if (_classSize.value == null || !numberCheck.hasMatch(_classSize.value)) {
      _classSize.addError(ValidationErrors.sizeOfClassError);
      flag = true;
    }

    if (_preparationHours.value == null ||
        !numberWithZeroCheck.hasMatch(_preparationHours.value)) {
      _preparationHours.addError(
        ValidationErrors.preprationTimeError,
      );
      flag = true;
    }
    return flag;
  }

  bool checkCreditError() {
    if (!validateForm()) {
      int prepHours = int.parse(_preparationHours.value);
      int classHours = int.parse(_classHours.value);
      int classSize = int.parse(_classSize.value);

      if (prepHours + classHours > classSize * classHours) {
        return true;
      }
    }
    return false;
  }

  @override
  void dispose() {
    _title.close();
    _classDescription.close();
    _preparationHours.close();
    _classHours.close();
    _classSize.close();
    _location.close();
    _status.close();
    _classSizeError.close();
  }
}
