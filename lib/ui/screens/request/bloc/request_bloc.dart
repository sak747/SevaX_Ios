import 'dart:developer' as developer;

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:rxdart/rxdart.dart';
import 'package:rxdart/subjects.dart';
import 'package:sevaexchange/models/models.dart';
import 'package:sevaexchange/repositories/firestore_keys.dart';
import 'package:sevaexchange/repositories/request_repository.dart';
import 'package:sevaexchange/utils/log_printer/log_printer.dart';
import 'package:sevaexchange/views/exchange/create_request/createrequest.dart';

class RequestBloc {
  final _requests = BehaviorSubject<RequestLists>();
  final _filter = BehaviorSubject<RequestFilter>.seeded(RequestFilter());
  final _loading = BehaviorSubject<bool>.seeded(false);
  final _loadingMore = BehaviorSubject<bool>.seeded(false);
  final _hasMore = BehaviorSubject<bool>.seeded(true);
  final _lastDoc = BehaviorSubject<DocumentSnapshot?>.seeded(null);
  final _allRequestsController = BehaviorSubject<List<RequestModel>>();

  Stream<RequestFilter> get filter => _filter.stream;
  Stream<RequestLists> get requests => _requests.stream;
  Stream<List<RequestModel>> get allRequests => _allRequestsController.stream;
  Stream<bool> get loading => _loading.stream;
  Stream<bool> get loadingMore => _loadingMore.stream;
  Stream<bool> get hasMore => _hasMore.stream;

  Function(RequestFilter) get onFilterChange => _filter.sink.add;
  void Function() get loadMore => _loadMore;

  String? _timebankId;
  String? _userId;

  void init(String timebankId, String userId) {
    _timebankId = timebankId;
    _userId = userId;
    _loading.add(true);
    final ref = CollectionRef.requests;
    var rawData = ref
        .where('timebanksPosted', arrayContains: timebankId)
        .where('softDelete', isEqualTo: false)
        .where('autoGenerated', isEqualTo: false)
        .limit(50)
        .snapshots();

    rawData.listen((snapshot) {
      List<RequestModel> models = [];
      snapshot.docs.forEach((documentSnapshot) {
        RequestModel model = RequestModel.fromMap(
            documentSnapshot.data() as Map<String, dynamic>);
        model.id = documentSnapshot.id;

        if (model.accepted != null && model.accepted == true) {
          if (model.sevaUserId == userId) {
            models.add(model);
          }
        } else {
          if ((model.isFromOfferRequest ?? false) == false) {
            models.add(model);
          }
        }
      });
      models.sort(
          (a, b) => (b.postTimestamp ?? 0).compareTo(a.postTimestamp ?? 0));
      _allRequestsController.add(models);
      if (snapshot.docs.isNotEmpty && _lastDoc.value == null) {
        _lastDoc.add(snapshot.docs.last);
      }
      if (_loading.value) {
        _loading.add(false);
      }
    });

    CombineLatestStream.combine2<List<RequestModel>, RequestFilter,
        RequestLists>(allRequests, filter, (models, filter) {
      RequestLists requestLists = RequestLists([], []);
      if (filter.isFilterSelected) {
        for (var model in models) {
          if (filter.timeRequest && model.requestType == RequestType.TIME) {
            if (!(model.isFromOfferRequest ?? false))
              requestLists.addRequest(userId, model);
            continue;
          }
          if (filter.cashRequest && model.requestType == RequestType.CASH) {
            requestLists.addRequest(userId, model);
            continue;
          }

          if (filter.oneToManyRequest &&
              model.requestType == RequestType.ONE_TO_MANY_REQUEST) {
            requestLists.addRequest(userId, model);
            continue;
          }

          if (filter.borrowRequest && model.requestType == RequestType.BORROW) {
            requestLists.addRequest(userId, model);
            continue;
          }

          if (filter.goodsRequest && model.requestType == RequestType.GOODS) {
            requestLists.addRequest(userId, model);
            continue;
          }
          if (filter.publicRequest && (model.public ?? false)) {
            requestLists.addRequest(userId, model);
            continue;
          }
          if (filter.virtualRequest && (model.virtualRequest ?? false)) {
            requestLists.addRequest(userId, model);
            continue;
          }
        }
      } else {
        models.forEach((model) {
          if (!(model.isFromOfferRequest ?? false))
            requestLists.addRequest(userId, model);
        });
      }
      return requestLists;
    }).listen((value) {
      _requests.add(value);
    });
  }

  Future<void> _loadMore() async {
    if (!_hasMore.value ||
        _loadingMore.value ||
        _lastDoc.value == null ||
        _timebankId == null ||
        _userId == null) return;
    _loadingMore.add(true);
    try {
      final moreDocs = await RequestRepository.getMoreRequestsOfTimebank(
        _timebankId!,
        _userId!,
        _lastDoc.value!,
        limit: 50,
      );
      if (moreDocs.isEmpty) {
        _hasMore.add(false);
        return;
      }
      List<RequestModel> moreModels = [];
      for (var doc in moreDocs) {
        RequestModel model =
            RequestModel.fromMap(doc.data() as Map<String, dynamic>);
        model.id = doc.id;
        if (model.accepted != null && model.accepted == true) {
          if (model.sevaUserId == _userId) {
            moreModels.add(model);
          }
        } else {
          if ((model.isFromOfferRequest ?? false) == false) {
            moreModels.add(model);
          }
        }
      }
      moreModels.sort(
          (a, b) => (b.postTimestamp ?? 0).compareTo(a.postTimestamp ?? 0));
      if (moreModels.isEmpty) {
        _hasMore.add(false);
        return;
      }
      final currentAll = _allRequestsController.value ?? [];
      final newAll = [...currentAll, ...moreModels];
      newAll.sort(
          (a, b) => (b.postTimestamp ?? 0).compareTo(a.postTimestamp ?? 0));
      _allRequestsController.add(newAll);
      _lastDoc.add(moreDocs.last);
      if (moreDocs.length < 50) {
        _hasMore.add(false);
      }
    } catch (e) {
      logger.e('Error loading more requests: $e');
    } finally {
      _loadingMore.add(false);
    }
  }

  void dispose() {
    _requests.close();
    _filter.close();
    _loading.close();
    _loadingMore.close();
    _hasMore.close();
    _lastDoc.close();
    _allRequestsController.close();
  }
}

class RequestLists {
  final List<RequestModel> myRequests;
  final List<RequestModel> communityRequests;

  void addRequest(String userId, RequestModel model) {
    if (model.requestMode == RequestMode.PERSONAL_REQUEST &&
        model.sevaUserId == userId) {
      myRequests?.add(model);
    } else {
      communityRequests?.add(model);
    }
  }

  bool get isEmpty => myRequests.isEmpty && communityRequests.isEmpty;

  RequestLists(this.myRequests, this.communityRequests);
}

class RequestFilter {
  final bool timeRequest;
  final bool goodsRequest;
  final bool cashRequest;
  final bool oneToManyRequest;
  final bool borrowRequest;
  final bool publicRequest;
  final bool virtualRequest;

  RequestFilter({
    this.timeRequest = false,
    this.goodsRequest = false,
    this.cashRequest = false,
    this.oneToManyRequest = false,
    this.borrowRequest = false,
    this.publicRequest = false,
    this.virtualRequest = false,
  });

  RequestFilter copyWith({
    bool? timeRequest,
    bool? goodsRequest,
    bool? cashRequest,
    bool? oneToManyRequest,
    bool? borrowRequest,
    bool? publicRequest,
    bool? virtualRequest,
  }) =>
      RequestFilter(
        timeRequest: timeRequest ?? this.timeRequest,
        goodsRequest: goodsRequest ?? this.goodsRequest,
        cashRequest: cashRequest ?? this.cashRequest,
        oneToManyRequest: oneToManyRequest ?? this.oneToManyRequest,
        borrowRequest: borrowRequest ?? this.borrowRequest,
        publicRequest: publicRequest ?? this.publicRequest,
        virtualRequest: virtualRequest ?? this.virtualRequest,
      );

  bool get isFilterSelected =>
      timeRequest ||
      goodsRequest ||
      cashRequest ||
      oneToManyRequest ||
      borrowRequest ||
      publicRequest ||
      virtualRequest;

  bool operator ==(Object other) {
    if (other is RequestFilter) {
      return this.timeRequest == other.timeRequest &&
          this.goodsRequest == other.goodsRequest &&
          this.cashRequest == other.cashRequest &&
          this.oneToManyRequest == other.oneToManyRequest &&
          this.borrowRequest == other.borrowRequest &&
          this.publicRequest == other.publicRequest &&
          this.virtualRequest == other.virtualRequest;
    } else {
      return false;
    }
  }

  bool checkFilter(RequestModel model) {
    if (isFilterSelected) {
      if (timeRequest && model.requestType == RequestType.TIME) {
        return true;
      } else if (cashRequest && model.requestType == RequestType.CASH) {
        return true;
      } else if (oneToManyRequest &&
          model.requestType == RequestType.ONE_TO_MANY_REQUEST) {
        return true;
      } else if (goodsRequest && model.requestType == RequestType.GOODS) {
        return true;
      } else if (borrowRequest && model.requestType == RequestType.BORROW) {
        return true;
      } else if (publicRequest && (model.public ?? false)) {
        return true;
      } else if (virtualRequest && (model.virtualRequest ?? false)) {
        return true;
      } else {
        return false;
      }
    } else {
      return true;
    }
  }
}
