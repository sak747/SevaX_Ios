import 'dart:async';
import 'dart:developer';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:geoflutterfire_plus/geoflutterfire_plus.dart';
import 'package:meta/meta.dart';
import 'package:sevaexchange/components/get_location.dart';
import 'package:sevaexchange/models/offer_model.dart';
import 'package:sevaexchange/models/request_model.dart';
import 'package:sevaexchange/repositories/firestore_keys.dart';
import 'package:sevaexchange/ui/utils/location_helper.dart';
import 'package:sevaexchange/utils/log_printer/log_printer.dart';

GeoFirePoint geoFlutterFire = GeoFirePoint(GeoPoint(0, 0));

Stream<List<OfferModel>> getOffersStream({
  required String timebankId,
  required String loggedInMemberSevaUserId,
}) async* {
  logger.i("offer list request started");
  // Stopwatch sw = Stopwatch();
  // sw.start();
  var query = CollectionRef.offers
      .where('timebanksPosted', arrayContains: timebankId)
      .where('assossiatedRequest', isNull: true)
      .where('softDelete', isEqualTo: false)
      .where('autoGenerated', isEqualTo: false);

  var data = query.snapshots();
  logger.i("fetched data");
  // Do not await LocationHelper.getCoordinates() here â€” awaiting it
  // blocks this async* generator from yielding any snapshots which
  // prevents the CombineLatestStream consumer from receiving data
  // (causing the UI to show a perpetual loader). If coordinates are
  // needed later, fetch them asynchronously without blocking the
  // Firestore snapshot stream.
  // Example: LocationHelper.getCoordinates().then((coords) { /* use coords */ });

  yield* data.transform(
    StreamTransformer<QuerySnapshot<Map<String, dynamic>>,
        List<OfferModel>>.fromHandlers(
      handleData: (snapshot, offerSink) async {
        List<OfferModel> offerList = [];

        for (final doc in snapshot.docs) {
          try {
            final data = doc.data();
            if (data is Map<String, dynamic>) {
              try {
                OfferModel model = OfferModel.fromMap(data);
                log('${model.id ?? ''}--->${model.offerType.toString()}');

                model.id = doc.id;
                // Uncomment and implement this if OfferModel supports currentUserLocation
                // model.currentUserLocation = coordinates;

                if (model.offerType == OfferType.GROUP_OFFER &&
                    (model.groupOfferDataModel?.isCanceled != true)) {
                  offerList.add(model);
                } else if (model.offerType == OfferType.INDIVIDUAL_OFFER) {
                  if ((model.individualOfferDataModel?.timeOfferType ==
                          'ONE_TIME') &&
                      (model.individualOfferDataModel?.isAccepted == true)) {
                    if (model.sevaUserId == loggedInMemberSevaUserId) {
                      offerList.add(model);
                    }
                  } else {
                    if ((model.type == RequestType.LENDING_OFFER &&
                        (model.lendingOfferDetailsModel?.lendingOfferTypeMode ==
                            "ONE_TIME") &&
                        (model.individualOfferDataModel?.isAccepted == true))) {
                      // Do nothing
                    } else {
                      offerList.add(model);
                    }
                  }
                }
              } catch (e) {
                logger.e("Error parsing OfferModel from document ${doc.id}: $e");
                // Skip this document and continue with others
              }
            }
          } catch (e) {
            logger.e("Error accessing document data: $e");
            // Skip this document and continue with others
          }
        }

        // Sort by timestamp descending in memory to avoid composite index requirement
        offerList
            .sort((a, b) => (b.timestamp ?? 0).compareTo(a.timestamp ?? 0));

        offerSink.add(offerList);
        // logger.i('offer loading time ${sw.elapsedMilliseconds}');
      },
    ),
  );
  // sw.stop();
}

Future<void> createOffer({required OfferModel offerModel}) async {
  await CollectionRef.offers.doc(offerModel.id).set(offerModel.toMap());
}

Future<void> updateOffersByFields({
  required List<String> offerIds,
  required Map<String, dynamic> fields,
}) async {
  var futures = <Future>[];
  int i;
  for (i = 0; i < offerIds.length; i++) {
    futures.add(CollectionRef.offers.doc(offerIds[i]).update(fields));
  }
  await Future.wait(futures);
}

Future<List<String>> createRecurringEventsOffer({
  required OfferModel offerModel,
}) async {
  var batch = CollectionRef.batch;

  bool lastRound = false;
  DateTime eventStartDate = DateTime.fromMillisecondsSinceEpoch(
          offerModel.groupOfferDataModel?.startDate ?? 0),
      eventEndDate = DateTime.fromMillisecondsSinceEpoch(
          offerModel.groupOfferDataModel?.endDate ?? 0);
  List<Map<String, dynamic>> temparr = [];
  List<String> offerIds = [];
  offerIds.add(offerModel.id ?? '');

  // Removed unused variable: DocumentSnapshot projectDoc = null;

  if (offerModel.end?.endType == "on") {
    //end type is on
    int occurenceCount = 2;
    var numTemp = 0;
    while (lastRound == false) {
      eventStartDate = DateTime(
          eventStartDate.year,
          eventStartDate.month,
          eventStartDate.day + 1,
          eventStartDate.hour,
          eventStartDate.minute,
          eventStartDate.second);
      eventEndDate = DateTime(
          eventEndDate.year,
          eventEndDate.month,
          eventEndDate.day + 1,
          eventEndDate.hour,
          eventEndDate.minute,
          eventEndDate.second);

      if (eventStartDate.millisecondsSinceEpoch <= (offerModel.end?.on ?? 0) &&
          occurenceCount < 11) {
        numTemp = eventStartDate.weekday % 7;
        if ((offerModel.recurringDays ?? []).contains(numTemp)) {
          OfferModel temp = offerModel;
          temp.groupOfferDataModel?.startDate =
              eventStartDate.millisecondsSinceEpoch;
          temp.groupOfferDataModel?.endDate =
              eventEndDate.millisecondsSinceEpoch;
          temp.timestamp = DateTime.now().millisecondsSinceEpoch;
          temp.id = (temp.email ?? '') +
              "*" +
              temp.timestamp.toString() +
              "*" +
              (temp.groupOfferDataModel?.startDate?.toString() ?? '');
          temp.occurenceCount = occurenceCount;
          occurenceCount++;
          temp.softDelete = false;
          temp.isRecurring = false;
          temp.autoGenerated = true;
          temparr.add(temp.toMap());
        }
      } else {
        lastRound = true;
        break;
      }
    }
  } else {
    //end type is after
    var numTemp = 0;
    int occurenceCount = 2;
    while (occurenceCount <= (offerModel.end?.after ?? 0)) {
      eventStartDate = DateTime(
          eventStartDate.year,
          eventStartDate.month,
          eventStartDate.day + 1,
          eventStartDate.hour,
          eventStartDate.minute,
          eventStartDate.second);
      eventEndDate = DateTime(
          eventEndDate.year,
          eventEndDate.month,
          eventEndDate.day + 1,
          eventEndDate.hour,
          eventEndDate.minute,
          eventEndDate.second);

      numTemp = eventStartDate.weekday % 7;
      if ((offerModel.recurringDays ?? []).contains(numTemp)) {
        OfferModel temp = offerModel;
        temp.groupOfferDataModel?.startDate =
            eventStartDate.millisecondsSinceEpoch;
        temp.groupOfferDataModel?.endDate = eventEndDate.millisecondsSinceEpoch;
        temp.timestamp = DateTime.now().millisecondsSinceEpoch;
        temp.id = (temp.email ?? '') +
            "*" +
            temp.timestamp.toString() +
            "*" +
            (temp.groupOfferDataModel?.startDate?.toString() ?? '');
        temp.occurenceCount = occurenceCount;
        occurenceCount++;
        temp.softDelete = false;
        temp.isRecurring = false;
        temp.autoGenerated = true;
        temparr.add(temp.toMap());
      }
      if (occurenceCount > (offerModel.end?.after ?? 0)) {
        break;
      }
    }
  }

  temparr.forEach((tempobj) {
    batch.set(CollectionRef.offers.doc(tempobj['id']), tempobj);
    offerIds.add(tempobj['id']);
    log("---------   ${DateTime.fromMillisecondsSinceEpoch(tempobj['groupOfferDataModel']['startDate']).toString()} with occurence count of ${tempobj['occurenceCount']}");
  });

  await batch.commit();
  return offerIds;
}

Future<void> updateRecurrenceOffersFrontEnd({
  required OfferModel updatedOfferModel,
}) async {
  var batch = CollectionRef.batch;
  bool lastRound = false;
  String uuidvar = "";
  OfferModel? eventData;
  // Removed unused variable: parentEvent

  List<OfferModel> upcomingEventsArr = [], prevEventsArr = [];
  var futures = <Future>[];
  Set<String> usersIds = {};
  DateTime eventStartDate = DateTime.fromMillisecondsSinceEpoch(
          updatedOfferModel.groupOfferDataModel?.startDate ?? 0),
      eventEndDate = DateTime.fromMillisecondsSinceEpoch(
          updatedOfferModel.groupOfferDataModel?.endDate ?? 0);

  QuerySnapshot snapEvents = await CollectionRef.offers
      .where("parent_offer_id", isEqualTo: updatedOfferModel.parent_offer_id)
      .get();

  snapEvents.docs.forEach((eventDoc) {
    try {
      final data = eventDoc.data();
      if (data != null) {
        eventData = OfferModel.fromMap(data as Map<String, dynamic>);
        if (eventData?.occurenceCount == 1) {
          // parentEvent = eventData; // removed unused variable
        } else if ((eventData?.occurenceCount ?? 0) >
            (updatedOfferModel.occurenceCount ?? 0)) {
          upcomingEventsArr.add(eventData!);
        } else if ((eventData?.occurenceCount ?? 0) <
            (updatedOfferModel.occurenceCount ?? 0)) {
          prevEventsArr.add(eventData!);
        }
      }
    } catch (e) {
      logger.e("Error parsing event document: $e");
      // Skip this document and continue
    }
  });
  // s1 ---------- create set of events with updated data

  List<Map<String, dynamic>> temparr = [];

  if (updatedOfferModel.end?.endType == "on") {
    //end type is on
    int occurenceCount = (updatedOfferModel.occurenceCount ?? 0) + 1;
    var numTemp = 0;
    while (lastRound == false) {
      eventStartDate = DateTime(
          eventStartDate.year,
          eventStartDate.month,
          eventStartDate.day + 1,
          eventStartDate.hour,
          eventStartDate.minute,
          eventStartDate.second);
      eventEndDate = DateTime(
          eventEndDate.year,
          eventEndDate.month,
          eventEndDate.day + 1,
          eventEndDate.hour,
          eventEndDate.minute,
          eventEndDate.second);
      if (eventStartDate.millisecondsSinceEpoch <=
              (updatedOfferModel.end?.on ?? 0) &&
          occurenceCount < 11) {
        numTemp = eventStartDate.weekday % 7;
        if ((updatedOfferModel.recurringDays ?? []).contains(numTemp)) {
          OfferModel temp = updatedOfferModel;
          temp.groupOfferDataModel?.startDate =
              eventStartDate.millisecondsSinceEpoch;
          temp.groupOfferDataModel?.endDate =
              eventEndDate.millisecondsSinceEpoch;
          temp.timestamp = DateTime.now().millisecondsSinceEpoch;
          temp.id = (temp.email ?? '') +
              "*" +
              temp.timestamp.toString() +
              "*" +
              (temp.groupOfferDataModel?.startDate?.toString() ?? '');
          temp.occurenceCount = occurenceCount;
          occurenceCount++;
          temp.softDelete = false;
          temp.isRecurring = false;
          temp.autoGenerated = true;
          temparr.add(temp.toMap());
        }
      } else {
        lastRound = true;
        break;
      }
    }
  } else {
    //end type is after
    var numTemp = 0;
    int occurenceCount = (updatedOfferModel.occurenceCount ?? 0) + 1;
    while (occurenceCount <= (updatedOfferModel.end?.after ?? 0)) {
      eventStartDate = DateTime(
          eventStartDate.year,
          eventStartDate.month,
          eventStartDate.day + 1,
          eventStartDate.hour,
          eventStartDate.minute,
          eventStartDate.second);
      eventEndDate = DateTime(
          eventEndDate.year,
          eventEndDate.month,
          eventEndDate.day + 1,
          eventEndDate.hour,
          eventEndDate.minute,
          eventEndDate.second);
      numTemp = eventStartDate.weekday % 7;
      if ((updatedOfferModel.recurringDays ?? []).contains(numTemp)) {
        OfferModel temp = updatedOfferModel;
        temp.groupOfferDataModel?.startDate =
            eventStartDate.millisecondsSinceEpoch;
        temp.groupOfferDataModel?.endDate = eventEndDate.millisecondsSinceEpoch;
        temp.timestamp = DateTime.now().millisecondsSinceEpoch;
        temp.id = (temp.email ?? '') +
            "*" +
            temp.timestamp.toString() +
            "*" +
            (temp.groupOfferDataModel?.startDate?.toString() ?? '');
        temp.occurenceCount = occurenceCount;
        occurenceCount++;
        temp.softDelete = false;
        temp.isRecurring = false;
        temp.autoGenerated = true;
        temparr.add(temp.toMap());
      }
      if (occurenceCount > (updatedOfferModel.end?.after ?? 0)) {
        break;
      }
    }
  }

  temparr.forEach((tempobj) {
    batch.set(CollectionRef.offers.doc(tempobj['id']), tempobj);
    log("---------   ${DateTime.fromMillisecondsSinceEpoch(tempobj['groupOfferDataModel']['startDate']).toString()} with occurence count of ${tempobj['occurenceCount']}");
  });

  // s2 ---------- update parent request and previous events with end data of updated event model

  batch.update(CollectionRef.offers.doc(updatedOfferModel.parent_offer_id), {
    "end": updatedOfferModel.end?.toMap(),
    "recurringDays": updatedOfferModel.recurringDays
  });

  // s3 ---------- delete old recurrences since the updated model

  if (upcomingEventsArr.length != 0) {
    upcomingEventsArr.forEach((upcomingEvent) {
      batch.delete(CollectionRef.offers
          .doc(upcomingEvent.id)); // delete old upcoming recurrence-events
    });
  }

  // s5 ---------- send notifications in case users have part of members

  upcomingEventsArr.forEach((upcomingEvent) {
    if (upcomingEvent.groupOfferDataModel!.signedUpMembers!.length > 0) {
      upcomingEvent.groupOfferDataModel!.signedUpMembers!
          .forEach((signedUpMemberId) {
        usersIds.add(signedUpMemberId);
      });
    }
  });
  List<String> usersIdsList = [];
  usersIdsList = usersIds.toList();
  int startIndex = 0, endIndex;

  if (usersIdsList.length > 0) {
    if (usersIdsList.length > 10) {
      for (endIndex = 10; endIndex < usersIdsList.length; endIndex += 10) {
        futures.add(CollectionRef.users
            .where("sevauserid",
                whereIn: usersIdsList.sublist(startIndex, endIndex))
            .get());
        startIndex = endIndex;
      }
    }
    futures.add(CollectionRef.users
        .where("sevauserid",
            whereIn: usersIdsList.sublist(startIndex, usersIdsList.length))
        .get());

    var futuresResult = await Future.wait(futures);

    futuresResult.forEach((snapUser) {
      if (!snapUser.documents.isEmpty) {
        snapUser.docs.forEach((docUser) {
          upcomingEventsArr.forEach((OfferModel upcomingEvent) {
            if (upcomingEvent.groupOfferDataModel!.signedUpMembers!
                .contains(docUser.data['sevauserid'])) {
              uuidvar = Uuid().generateV4();
              batch.set(
                  CollectionRef.users
                      .doc(docUser.id)
                      .collection("notifications")
                      .doc(uuidvar),
                  {
                    'communityId': upcomingEvent.communityId,
                    'data': {
                      'eventName':
                          upcomingEvent.groupOfferDataModel!.classTitle,
                      'eventDate': upcomingEvent.groupOfferDataModel!.startDate,
                      'offerId': upcomingEvent.id,
                    },
                    'id': uuidvar,
                    'isRead': false,
                    'senderUserId': upcomingEvent.sevaUserId,
                    'timebankId': upcomingEvent.timebankId,
                    'timestamp': DateTime.now().millisecondsSinceEpoch,
                    'type': "RecurringOfferUpdated",
                    'userId': docUser.data['sevauserid']
                  });
            }
          });
        });
      }
    });
  }

  // s6 ---------- change in projects pendingrequests, and put it all into a batch and commit them

  await batch.commit();
}

// Stream<List<OfferModel>> getOfferNotificationStream({
//   @required String userId,
// }) async* {
//   var data = CollectionRef.collection('notifications')
//       .doc(userId)
//       .collection('offerRequest')
//       .snapshots();

//   yield* data.transform(
//     StreamTransformer<QuerySnapshot, List<OfferModel>>.fromHandlers(
//       handleData: (snapshot, offerSink) {
//         List<OfferModel> offerList = [];
//         snapshot.docs.forEach((documentSnapshot) {
//           OfferModel offer = OfferModel.fromMap(documentSnapshot.data);
//           offerList.add(offer);
//         });
//         offerSink.add(offerList);
//       },
//     ),
//   );
// }

// Stream<List<RequestModel>> getOfferRequestApprovedNotificationStream({
//   @required String userId,
// }) async* {
//   var data = CollectionRef.collection('notifications')
//       .doc(userId)
//       .collection('offerAccepted')
//       .snapshots();

//   yield* data.transform(
//     StreamTransformer<QuerySnapshot, List<RequestModel>>.fromHandlers(
//       handleData: (snapshot, requestSink) {
//         List<RequestModel> requestList = [];
//         snapshot.docs.forEach((document) {
//           RequestModel model = RequestModel.fromMap(document.data());
//           model.id = document.id;
//           requestList.add(model);
//         });
//         requestSink.add(requestList);
//       },
//     ),
//   );
// }

// Future<void> deleteOfferRequestApproval({
//   @required RequestModel request,
// }) async {
//   await CollectionRef.collection('notifications')
//       .doc(request.sevaUserId)
//       .collection('offerAccepted')
//       .doc(request.id)
//       .delete();
// }

Future<void> updateOfferWithRequest({
  required OfferModel offer,
}) async {
  await CollectionRef.offers.doc(offer.id).update(offer.toMap());
}

Stream<List<OfferModel>> getBookMarkedOffers(
    {required String sevaUserId, required String timebankid}) async* {
  var data = CollectionRef.offers
      .where(
        'individualOfferDataModel.offerAcceptors',
        arrayContains: sevaUserId,
      )
      .snapshots();

  yield* data.transform(
    StreamTransformer<QuerySnapshot<Map<String, dynamic>>,
        List<OfferModel>>.fromHandlers(
      handleData: (snapshot, offerSink) async {
        List<OfferModel> offerList = [];

        snapshot.docs.forEach((snapshot) {
          try {
            final data = snapshot.data();
            if (data != null) {
              OfferModel model = OfferModel.fromMap(data as Map<String, dynamic>);
              model.id = snapshot.id;

              if (model.timebanksPosted != null &&
                  model.timebanksPosted!.contains(timebankid)) {
                offerList.add(model);
              }
            }
          } catch (e) {
            logger.e("Error parsing bookmarked offer: $e");
            // Skip this document and continue
          }
        });
        // Sort by timestamp descending in memory to avoid composite index requirement
        offerList
            .sort((a, b) => (b.timestamp ?? 0).compareTo(a.timestamp ?? 0));

        offerSink.add(offerList);
      },
    ),
  );
}
