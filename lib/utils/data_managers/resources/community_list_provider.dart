import 'dart:async';
import 'dart:developer';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:sevaexchange/models/models.dart';
import 'package:sevaexchange/new_baseline/models/community_model.dart';
import 'package:sevaexchange/repositories/firestore_keys.dart';
import 'package:sevaexchange/utils/data_managers/blocs/communitylist_bloc.dart';

class RequestApiProvider {
  Future<List<UserModel>> getUserFromRequest(String requestID) async {
    List<UserModel> usersDataList = [];

    var query =
        CollectionRef.users.where("invitedRequests", arrayContains: requestID);

    QuerySnapshot querySnapshot = await query.get();

    querySnapshot.docs.forEach((documentSnapshot) {
      UserModel model = UserModel.fromMap(
          documentSnapshot.data() as Map<String, dynamic>,
          'community_list_provider');
      usersDataList.add(model);
    });
    return usersDataList;
  }

  Future<List<RequestModel>> getRequestListFuture(String timebankId) async {
    List<RequestModel> requestList = [];
    var query = timebankId == null || timebankId == 'All'
        ? CollectionRef.requests
            .where('accepted', isEqualTo: false)
        : CollectionRef.requests
            .where('timebankId', isEqualTo: timebankId)
            .where('accepted', isEqualTo: false);

    QuerySnapshot querySnapshot = await query.get();
    querySnapshot.docs.forEach((documentSnapshot) {
      RequestModel model =
          RequestModel.fromMap(documentSnapshot.data() as Map<String, dynamic>);
      model.id = documentSnapshot.id;
      if (model.approvedUsers!.length <= model.numberOfApprovals!) {
        requestList.add(model);
      }
    });
    // Sort by postTimestamp descending in memory to avoid composite index requirement
    requestList.sort((a, b) => (b.postTimestamp ?? 0).compareTo(a.postTimestamp ?? 0));
    return requestList;
  }

  Future<List<RequestModel>> getProjectCompletedList(
      {String? projectId}) async {
    List<RequestModel> requestList = [];
    var query = CollectionRef.requests
        .where('accepted', isEqualTo: true)
        .where('projectId', isEqualTo: projectId);

    QuerySnapshot querySnapshot = await query.get();
    querySnapshot.docs.forEach((documentSnapshot) {
      RequestModel model =
          RequestModel.fromMap(documentSnapshot.data() as Map<String, dynamic>);
      model.id = documentSnapshot.id;
      requestList.add(model);
    });
    return requestList;
  }

  Future<List<RequestModel>> getProjectPendingList({String? projectId}) async {
    List<RequestModel> requestList = [];
    var query = CollectionRef.requests
        .where('accepted', isEqualTo: false)
        .where('projectId', isEqualTo: projectId);

    QuerySnapshot querySnapshot = await query.get();
    querySnapshot.docs.forEach((documentSnapshot) {
      RequestModel model =
          RequestModel.fromMap(documentSnapshot.data() as Map<String, dynamic>);
      model.id = documentSnapshot.id;
      requestList.add(model);
    });
    return requestList;
  }

  Stream<List<RequestModel>> getRequestListStream(
      {String? timebankId, String? userId}) async* {
    var query = timebankId == null || timebankId == 'All'
        ? CollectionRef.requests
            .where('autoGenerated', isEqualTo: false)
            .where('softDelete', isEqualTo: false)
        : CollectionRef.requests
            .where('timebanksPosted', arrayContains: timebankId)
            .where('softDelete', isEqualTo: false)
            .where('autoGenerated', isEqualTo: false);

    var data = query.snapshots();

    yield* data.transform(
      StreamTransformer<QuerySnapshot, List<RequestModel>>.fromHandlers(
        handleData: (snapshot, requestSink) {
          List<RequestModel> requestList = [];
          snapshot.docs.forEach(
            (documentSnapshot) {
              RequestModel model = RequestModel.fromMap(
                  documentSnapshot.data() as Map<String, dynamic>);
              model.id = documentSnapshot.id;
              if (model.accepted!) {
                if (model.sevaUserId == userId) {
                  requestList.add(model);
                }
              } else {
                if (!model.isFromOfferRequest!) {
                  requestList.add(model);
                }
              }
            },
          );

          // Sort by postTimestamp descending in memory to avoid composite index requirement
          requestList.sort((a, b) => (b.postTimestamp ?? 0).compareTo(a.postTimestamp ?? 0));

          requestSink.add(requestList);
        },
      ),
    );
  }

  Future<void> updateInvitedUsersForRequest(
    String requestID,
    String sevaUserId,
    String email,
  ) async {
    List<String> list = [];
    list.add(sevaUserId);

    var batch = CollectionRef.batch;

    batch.update(CollectionRef.requests.doc(requestID), {
      'invitedUsers': FieldValue.arrayUnion([sevaUserId])
    });

    batch.update(
      CollectionRef.users.doc(email),
      {
        'invitedRequests': FieldValue.arrayUnion([requestID])
      },
    );

    await batch.commit().then((onValue) {
      log("Updated invitedUsers");
    }).catchError((onError) {
      log("Error Updating invitedUsers");
    });
  }
}

class CommunityApiProvider {
//  Future<CategoryListModel> fetchCategoryList() async {
//    Response response;
//    if(_apiKey != 'api-key') {
//       response = await client.get("$_baseUrl/popular?api_key=$_apiKey");
//    }else{
//      throw Exception('Please add your API key');
//    }
//    if (response.statusCode == 200) {
//      // If the call to the server was successful, parse the JSON
//      return CategoryListModel.fromJson(json.decode(response.body));
//    } else {
//      // If that call was not successful, throw an error.
//      throw Exception('Failed to load post');
//    }
//  }

  Future<bool> isCommunityFound(String enteredName) async {
    //ommunityBloc.fetchCommunities(enteredName);
    CommunityListModel communities = CommunityListModel();
    var communitiesFound =
        await searchCommunityByName(enteredName, communities);
    if (communitiesFound == null ||
        communitiesFound.communities == null ||
        communitiesFound.communities.length == 0) {
      return false;
    } else {
      return true;
    }
  }

  Future<CommunityListModel> searchCommunityByName(
      String name, CommunityListModel communities) async {
    communities.removeall();
    if (name.isNotEmpty && name.length > 4) {
      await CollectionRef.communities
          .where('name', isEqualTo: name)
          .get()
          .then((QuerySnapshot querySnapshot) {
        querySnapshot.docs.forEach((DocumentSnapshot documentSnapshot) {
          var community =
              CommunityModel(documentSnapshot.data() as Map<String, dynamic>);

          communities.add(community);
        });
      });
    }
    return communities;
  }

  Future<TimebankListModel> searchTimebankSiblingsByParentId(
      String id, TimebankListModel timebanks) async {
    timebanks.removeall();
    if (id.isNotEmpty) {
      await CollectionRef.timebank
          .where('associatedParentTimebankId', isEqualTo: id)
          .get()
          .then((QuerySnapshot querySnapshot) {
        querySnapshot.docs.forEach((DocumentSnapshot documentSnapshot) {
          var timebank = TimebankModel(documentSnapshot.data());
          timebanks.add(timebank);
        });
      });
    }
    return timebanks;
  }

  Future<void> updateCommunityWithUserId(communityId, userId) async {
    var response = await CollectionRef.communities.doc(communityId).update({
      'members': FieldValue.arrayUnion([userId])
    });
    return response;
  }

  Future<void> createCommunityByName(CommunityModel community) async {
    await CollectionRef.communities.doc(community.id).set(community.toMap());
  }

  Future<void> updateUserWithTimeBankIdCommunityId(
      UserModel user, timebankId, communityId) async {
    // if user is already part of community
    var found = false;
    if (user.communities != null) {
      for (var i = 0; i < user.communities!.length; i++) {
        if (user.communities![i] == communityId) {
          found = true;
        }
      }
    } else {
      user.communities = [];
    }
    if (!found) {
      user.communities = [
        ...user.communities!,
        ...[communityId]
      ];
    }
    found = false;
    if (user.membershipTimebanks != null) {
      for (var i = 0; i < user.membershipTimebanks!.length; i++) {
        if (user.membershipTimebanks![i] == timebankId) {
          found = true;
        }
      }
    } else {
      user.membershipTimebanks = [];
    }
    if (!found) {
      user.membershipTimebanks = [
        ...user.membershipTimebanks!,
        ...[timebankId]
      ];
    }
    await CollectionRef.users
        .doc(user.email)
        .update({
          'membershipTimebanks': user.membershipTimebanks,
          'communities': user.communities,
          'currentCommunity': communityId
        })
        .then((onValue) {})
        .catchError((onError) {});
  }
}
