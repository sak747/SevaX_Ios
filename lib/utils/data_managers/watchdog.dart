import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:sevaexchange/l10n/l10n.dart';
import 'package:sevaexchange/models/request_model.dart';
import 'package:sevaexchange/new_baseline/models/project_model.dart';
import 'package:sevaexchange/repositories/firestore_keys.dart';
import 'package:sevaexchange/utils/log_printer/log_printer.dart';
import 'package:sevaexchange/utils/utils.dart';

class DialogsManager {
  static Future<bool> showDilaogWithTitle({
    required BuildContext context,
    required String title,
    required String positiveTitle,
    required String negativeTitle,
  }) async {
    return showDialog(
      context: context,
      builder: (_context) {
        return AlertDialog(
          actions: [
            Row(
              children: [
                ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.red,
                  ),
                  child: Container(
                    width: 100,
                    child: Text(
                      negativeTitle,
                      textAlign: TextAlign.center,
                      style: TextStyle(
                        color: Colors.white,
                      ),
                    ),
                  ),
                  onPressed: () {
                    Navigator.of(_context).pop(false);
                  },
                ),
                SizedBox(width: 16),
                ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.green,
                  ),
                  child: Container(
                    width: 150,
                    child: Text(
                      positiveTitle,
                      textAlign: TextAlign.center,
                      style: TextStyle(
                        color: Colors.white,
                      ),
                    ),
                  ),
                  onPressed: () {
                    Navigator.of(_context).pop(true);
                  },
                ),
              ],
            )
          ],
          title: Text(title),
        );
      },
    ).then((value) => value);
  }
}

class WatchDog {
  static Future<bool> cloneAndCreateRecurringEventsFromExisting({
    ProjectModel? eventModel,
  }) async {
    return await CollectionRef.requests
        .where('projectId', isEqualTo: eventModel!.id)
        .get()
        .then((value) async {
      WriteBatch batch = CollectionRef.batch;
      int batchCount = 0;
      Map<String, List<RequestModel>> recurringRequestList = {};

      //Handle Recurring
      value.docs.forEach((originalRequestSnapshot) {
        var originalRequest = RequestModel.fromMap(
                originalRequestSnapshot.data() as Map<String, dynamic>)
            .flush;

        if (originalRequest.isRecurring! || originalRequest.autoGenerated!) {
          var a = originalRequest.parent_request_id;
          if (recurringRequestList.containsKey(a)) {
            List<RequestModel> recurringRequestsList = recurringRequestList[a]!;
            recurringRequestsList.add(originalRequest);
            recurringRequestList[a!] = recurringRequestsList;
          } else {
            List<RequestModel> recurringRequestsList = [];
            recurringRequestsList.add(originalRequest);
            recurringRequestList[a!] = recurringRequestsList;
          }
        }
      });

      var eventIdArray = await createRecurringEventsFromExisting(eventModel);

      eventIdArray.forEach((eventId) {
        //CLONE NON RECURRING PART
        value.docs.forEach((originalRequestSnapshot) {
          var originalRequest = RequestModel.fromMap(
                  originalRequestSnapshot.data() as Map<String, dynamic>)
              .flush;
          if (!originalRequest.isRecurring! &&
              !originalRequest.autoGenerated!) {
            //THESE ARE NON RECURRING REQUESTS INSIDE EVENTS
            originalRequest.projectId = eventId;
            batchCount++;
            batch.set(
              CollectionRef.requests.doc(originalRequest.id),
              originalRequest.toMap(),
            );
            // batch.add(originalRequest);
          }
        });

        //CLONE RECURRING PART
        recurringRequestList.forEach((key, requestList) {
          //add list here
          var newParentId = Utils.getUuid();
          requestList.forEach((element) {
            RequestModel requestModel = element.flush;
            requestModel.projectId = eventId;
            requestModel.parent_request_id = newParentId;
            if (requestModel.isRecurring!) {
              requestModel.id = newParentId;
            }
            batchCount++;
            batch.set(
              FirebaseFirestore.instance
                  .collection("requests")
                  .doc(requestModel.id),
              requestModel.toMap(),
            );
          });
        });
      });

      return await batch.commit().then((value) {
        return true;
      }).catchError((onError) {
        return false;
      });
    });
  }

  static Future<List<String>> createRecurringEventsFromExisting(
      ProjectModel projectModel) async {
    // Update existing project model to recurring
    //Create new events as prescribed my admin
    var batch = CollectionRef.batch;
    DateTime eventStartDate =
        DateTime.fromMillisecondsSinceEpoch(projectModel.startTime!);
    DateTime eventEndDate =
        DateTime.fromMillisecondsSinceEpoch(projectModel.endTime!);

    bool lastRound = false;
    List<Map<String, dynamic>> temparr = [];
    List<String> eventsIdsArr = [];
    batch.update(
        CollectionRef.projects.doc(projectModel.id), projectModel.toMap());

    if (projectModel.end!.endType == "on") {
      //end type is on
      int occurenceCount = 2;
      var numTemp = 0;
      while (lastRound == false) {
        eventStartDate = DateTime(
            eventStartDate.year,
            eventStartDate.month,
            eventStartDate.day + 1,
            eventStartDate.hour,
            eventStartDate.minute,
            eventStartDate.second);
        eventEndDate = DateTime(
            eventEndDate.year,
            eventEndDate.month,
            eventEndDate.day + 1,
            eventEndDate.hour,
            eventEndDate.minute,
            eventEndDate.second);

        if (eventStartDate.millisecondsSinceEpoch <= projectModel.end!.on!) {
          numTemp = eventStartDate.weekday % 7;
          if (projectModel.recurringDays!.contains(numTemp)) {
            ProjectModel temp = projectModel;
            temp.startTime = eventStartDate.millisecondsSinceEpoch;
            temp.endTime = eventEndDate.millisecondsSinceEpoch;
            temp.createdAt = DateTime.now().millisecondsSinceEpoch;
            temp.id = Utils.getUuid();
            temp.occurenceCount = occurenceCount;
            occurenceCount++;
            temp.softDelete = false;
            temp.isRecurring = false;
            temp.autoGenerated = true;
            temparr.add(temp.toMap());
          }
        } else {
          lastRound = true;
          break;
        }
      }
    } else {
      //end type is after
      var numTemp = 0;
      int occurenceCount = 2;
      while (occurenceCount <= projectModel.end!.after!) {
        eventStartDate = DateTime(
            eventStartDate.year,
            eventStartDate.month,
            eventStartDate.day + 1,
            eventStartDate.hour,
            eventStartDate.minute,
            eventStartDate.second);
        eventEndDate = DateTime(
          eventEndDate.year,
          eventEndDate.month,
          eventEndDate.day + 1,
          eventEndDate.hour,
          eventEndDate.minute,
          eventEndDate.second,
        );

        numTemp = eventStartDate.weekday % 7;
        if (projectModel.recurringDays!.contains(numTemp)) {
          ProjectModel temp = projectModel;
          temp.startTime = eventStartDate.millisecondsSinceEpoch;
          temp.endTime = eventEndDate.millisecondsSinceEpoch;
          temp.createdAt = DateTime.now().millisecondsSinceEpoch;
          temp.id = Utils.getUuid();
          temp.occurenceCount = occurenceCount;
          occurenceCount++;
          temp.softDelete = false;
          temp.isRecurring = false;
          temp.autoGenerated = true;
          temparr.add(temp.toMap());
        }
        if (occurenceCount > projectModel.end!.after!) {
          break;
        }
      }
    }

    // eventsIdsArr.add(projectModel.id);
    temparr.forEach((tempobj) {
      batch.set(CollectionRef.projects.doc(tempobj['id']), tempobj);
      eventsIdsArr.add(tempobj['id']);
    });

    await batch.commit();
    return eventsIdsArr;
  }

  static showDialogForUpdation({
    BuildContext? context,
    Function? updateSingleEvent,
    Function? updateSubsequentEvents,
  }) {
    showDialog(
        barrierDismissible: false,
        context: context!,
        builder: (BuildContext viewContext) {
          return WillPopScope(
              onWillPop: () async => false,
              child: AlertDialog(
                  title: Text(S.of(context).this_is_repeating_event),
                  actions: [
                    TextButton(
                      child: Text(
                        S.of(context).edit_this_event,
                        style: TextStyle(
                            fontSize: 14,
                            color: Colors.red,
                            fontFamily: 'Europa'),
                      ),
                      onPressed: () async {
                        //Update this event
                        await updateSingleEvent!();
                        Navigator.pop(viewContext);
                        Navigator.pop(context);
                      },
                    ),
                    TextButton(
                      child: Text(
                        S.of(context).edit_subsequent_event,
                        style: TextStyle(
                            fontSize: 14,
                            color: Colors.red,
                            fontFamily: 'Europa'),
                      ),
                      onPressed: () async {
                        //Update subsquent events
                        await updateSubsequentEvents!();
                        Navigator.pop(viewContext);
                        Navigator.pop(context);
                      },
                    ),
                    TextButton(
                      child: Text(
                        S.of(context).cancel,
                        style: TextStyle(
                            fontSize: 14,
                            color: Colors.red,
                            fontFamily: 'Europa'),
                      ),
                      onPressed: () async {
                        Navigator.pop(viewContext);
                      },
                    ),
                  ]));
        });
  }

  static Future<bool> updateSubsequentEvents(ProjectModel projectModel) async {
    var batch = CollectionRef.batch;

    var eventList =
        await getEventAssociatedWithParentEvent(projectModel.parentEventId!);

    var affectedEventIds = [];

    eventList.forEach((element) {
      if (element.occurenceCount! >= projectModel.occurenceCount!)
        affectedEventIds.add(element.id);
    });

    logger.d(affectedEventIds.length);

    affectedEventIds.forEach((element) {
      Map<String, dynamic> updatedDetails = {
        "name": projectModel.name,
        "description": projectModel.description,
        "public": projectModel.public,
        "virtualProject": projectModel.virtualProject,
        "email_id": projectModel.emailId,
        "address": projectModel.address,
        "registrationLink": projectModel.registrationLink,
        "timebanksPosted":
            List<dynamic>.from(projectModel.timebanksPosted!.map((x) => x)),
      };
      if (projectModel.location != null)
        updatedDetails['location'] = projectModel.location?.data;

      batch.update(
        CollectionRef.projects.doc(element),
        updatedDetails,
      );
    });
    return batch.commit().then((value) => true).catchError((onError) => false);
  }

  static Future<List<ProjectModel>> getEventAssociatedWithParentEvent(
    String parentEventId,
  ) {
    return CollectionRef.projects
        .where("parentEventId", isEqualTo: parentEventId)
        .get()
        .then((value) {
      List<ProjectModel> eventList = [];
      value.docs.forEach((event) {
        eventList
            .add(ProjectModel.fromMap(event.data() as Map<String, dynamic>));
      });
      return eventList;
    });
  }

  static Future<List<String>> createRecurringEvents({
    required ProjectModel projectModel,
  }) async {
    var batch = CollectionRef.batch;

    DateTime eventStartDate =
        DateTime.fromMillisecondsSinceEpoch(projectModel.startTime!);
    DateTime eventEndDate =
        DateTime.fromMillisecondsSinceEpoch(projectModel.endTime!);

    bool lastRound = false;
    List<Map<String, dynamic>> temparr = [];
    List<String> eventsIdsArr = [];
    batch.set(
        CollectionRef.projects.doc(projectModel.id), projectModel.toMap());

    if (projectModel.end!.endType == "on") {
      //end type is on
      int occurenceCount = 2;
      var numTemp = 0;
      while (lastRound == false) {
        eventStartDate = DateTime(
            eventStartDate.year,
            eventStartDate.month,
            eventStartDate.day + 1,
            eventStartDate.hour,
            eventStartDate.minute,
            eventStartDate.second);
        eventEndDate = DateTime(
            eventEndDate.year,
            eventEndDate.month,
            eventEndDate.day + 1,
            eventEndDate.hour,
            eventEndDate.minute,
            eventEndDate.second);

        if (eventStartDate.millisecondsSinceEpoch <= projectModel.end!.on!) {
          numTemp = eventStartDate.weekday % 7;
          if (projectModel.recurringDays!.contains(numTemp)) {
            ProjectModel temp = projectModel;
            temp.startTime = eventStartDate.millisecondsSinceEpoch;
            temp.endTime = eventEndDate.millisecondsSinceEpoch;
            temp.createdAt = DateTime.now().millisecondsSinceEpoch;
            temp.id = Utils.getUuid();
            temp.occurenceCount = occurenceCount;
            occurenceCount++;
            temp.softDelete = false;
            temp.isRecurring = false;
            temp.autoGenerated = true;
            temparr.add(temp.toMap());
          }
        } else {
          lastRound = true;
          break;
        }
      }
    } else {
      //end type is after
      var numTemp = 0;
      int occurenceCount = 2;
      while (occurenceCount <= projectModel.end!.after!) {
        eventStartDate = DateTime(
            eventStartDate.year,
            eventStartDate.month,
            eventStartDate.day + 1,
            eventStartDate.hour,
            eventStartDate.minute,
            eventStartDate.second);
        eventEndDate = DateTime(
          eventEndDate.year,
          eventEndDate.month,
          eventEndDate.day + 1,
          eventEndDate.hour,
          eventEndDate.minute,
          eventEndDate.second,
        );

        numTemp = eventStartDate.weekday % 7;
        if (projectModel.recurringDays!.contains(numTemp)) {
          ProjectModel temp = projectModel;
          temp.startTime = eventStartDate.millisecondsSinceEpoch;
          temp.endTime = eventEndDate.millisecondsSinceEpoch;
          temp.createdAt = DateTime.now().millisecondsSinceEpoch;
          temp.id = Utils.getUuid();
          temp.occurenceCount = occurenceCount;
          occurenceCount++;
          temp.softDelete = false;
          temp.isRecurring = false;
          temp.autoGenerated = true;
          temparr.add(temp.toMap());
        }
        if (occurenceCount > projectModel.end!.after!) {
          break;
        }
      }
    }

    eventsIdsArr.add(projectModel.id!);
    temparr.forEach((tempobj) {
      batch.set(CollectionRef.projects.doc(tempobj['id']), tempobj);
      eventsIdsArr.add(tempobj['id']);
    });

    await batch.commit();
    return eventsIdsArr;
  }
}
